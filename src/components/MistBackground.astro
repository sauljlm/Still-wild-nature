<div id="smoke-bkg" class="fixed top-0 h-full w-full"></div>

<script>
  import * as THREE from 'three'

  const $bkg = document.getElementById("smoke-bkg");

  let w = window.innerWidth;
  let h = window.innerHeight;

  // escena, cámara, render
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, w / h, 1, 1000);
  camera.position.z = 200;
  scene.add(camera);

  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
  renderer.setPixelRatio(1);
  renderer.setSize(w, h);
  renderer.setClearColor(0x000000, 1);

  $bkg?.appendChild(renderer.domElement);

  // Grupo principal (IMPORTANTE)
  const smokeGroup = new THREE.Group();
  scene.add(smokeGroup);

  const light = new THREE.DirectionalLight(0xffffff, 0.2);
  light.position.set(-1, 3, 1);
  scene.add(light);

  const smokeParticles = [];
  const loader = new THREE.TextureLoader();
  // loader.crossOrigin = "";

  loader.load('/images/mist.png', (texture) => {
    const smokeGeo = new THREE.PlaneGeometry(150, 150);
    const smokeMaterial = new THREE.MeshLambertMaterial({
      map: texture,
      transparent: true,
      depthWrite: false,
    });

    const NUM_OF_PARTICLES = 100;
    const MIN_DISTANCE = 150;
    const MAX_TRIES = 10;

    // Función para generar posición aleatoria dentro de un rango controlado
    function randomPosition() {
      return new THREE.Vector3(
        Math.random() * 300 - 150, // X
        Math.random() * 800 - 400,  // Y
        Math.random() * 300 + 80   // Z
      );
    }

    for (let p = 0; p < NUM_OF_PARTICLES; p++) {
      let pos;
      let valid = false;
      let tries = 0;

      // genera posiciones hasta encontrar una lo bastante separada
      while (!valid && tries < MAX_TRIES) {
        pos = randomPosition();
        valid = smokeParticles.every(
          (existing) => pos.distanceTo(existing.position) > MIN_DISTANCE
        );
        tries++;
      }

      const particle = new THREE.Mesh(smokeGeo, smokeMaterial);
      particle.position.copy(pos);
      particle.rotation.z = Math.random() * Math.PI * 2;
      smokeGroup.add(particle);
      smokeParticles.push(particle);
    }
  });

  // Scroll control
  let scrollY = 0;

  window.addEventListener("scroll", () => {
    scrollY = window.scrollY * 0.5;
  });

  // resize optimizado
  let resizeTimer;
  function resize() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      h = window.innerHeight;
      w = window.innerWidth;

      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      renderer.setSize(w, h);
    }, 100);
  }
  
  window.addEventListener("resize", resize);

  let lastTime = 0;
  function animate(time:number) {
    const delta = time - lastTime;
    if (delta < 33) return; // ~30 FPS
    lastTime = time;

    // Rotación individual
    smokeParticles.forEach((particle) => {
      particle.rotation.z += 0.0015;
      particle.position.y += 0.05;
    });

    // Movimiento global hacia arriba según scroll
    smokeGroup.position.y = scrollY * 0.1;

    renderer.render(scene, camera);
  }

  renderer.setAnimationLoop(animate);

</script>